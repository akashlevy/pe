* Every processor or processing element (e.g. in a spatial architecture) can be thought of as a single function of several inputs which outputs a tuple of values. If we want to think of a Verilog/RTL analog, this function would be the top-level module for the processing element, and the inputs and outputs would be the delcared `input` and `output` wires at the top of the module. Note that this abstract description applies to both a general puprose processor (like a CPU) as well as a PE in a spatial architecture/CGRA. See below how they may differ in implementation. Also, initially, we ignore the internal stateful-ness of the processing elements (i.e. it can be modeled as a pure function).
* The main claim while designing this DSL is that all a designer/programmer is doing is specifying both the interface/signature of that function, as well as the actual semantics of the function. From this claim, we note sevaral things:
  - We could offer the designer/programmer a very limited set of RTL-like tools to enable the specification of this function (e.g. a bit-vector class with overloaded operators), and ask the designer/programmer to specify the function in python (or in any high-level language really). Using this methodology, the designer/programmer has complete control over the semantics of the function. Of course, this is not at all useful since we are basically telling the designer/programmer to write a functional spec from scratch, which is what they are doing now anyway.
  - Therefore, the path to designing this DSL should maintain the original principle that the designer/programmer is simply specifying a single function, while automating (by making part of the native language semantics) as much of the common things as possible. Under this methodology, the designer/programmer **could** specify a function from scratch as mentioned above, but the language provides lots of features to make this easier. Also, the language should provide abstractions which align with the existing programming models in which **hardware designers** think. Specifically, we want hardware designers to use this language, and we don't want to force them to think like software programmers.
  - Ultimately, the task of designing the language boils down into a decision of (a) what to **provide** the progammer through inherent language syntax/structures, and (b) how to **restrict** the programmer so that the result of any code/spec is a proper spec.
* It is not immediately obvious how to design a DSL for specifying both processing elements of spatial architectures (e.g. CGRA) and those of temporal architectures (e.g. CPU). In fact, it need not be the case that they can or should be both specified using the same language. Along these lines, there are several thoughts:
  - It still makes sense to think about both in a functional way. At first glance, the fundamental difference between a **single** PE in a spatial architecture and a temporal processor is just that some inputs are *fixed* (for the lifetime of a configuration) in a spatial PE, where as all inputs are dynamic (i.e. vary in time) for a temporal PE. In this way, we could think about a reconfigurable processor (e.g. a spatial PE) as a *closure* over a set of specific configuration inputs, and a temporal PE as a normal function. To reconfigure the processor, we would have to compute a new closure. Going back to our initial hypothesis, we still maintain a simple functional model; however, in a spatial architecture the output of the function would be another function (the closure), where as in a temporal architecture the output would be a set of "real" outputs (i.e. wires).
  - This seemingly fundamental difference, is actually not so fundamental. Really, the fundamental difference between a PE in a spatial architecture and a PE in a temporal architecture is in their use, not in their operation. This is because even temporal PE's have some configuration state (e.g. performance counters) - it's just that this is often not on the critical path for functional specification. Again, the real distinction is in their use: spatial PE's are often tiled together with instructions/op-codes coming from on-tile registers that only change at configuration; temporal PE's are standalone components which read different instructions from memory over time (instruction fetch). The "decode" and "execute" stages of both types of processors are in fact quite similar.
  - Our hypothesis is that the language should allow specification of both types of procsessors in the same way. Specifically, we claim that there are two distinct types of input variables: dynamic and configuration. Once declared, both types of variables can be used in the same way - there is effectively no distinction downstream from the designer/programmers perspective. In terms of the language internals, however, they may have different meanings (e.g. they would correspond to different RTL, and different semantics in a functional model). This allows the progammer to decouple the functional interface of the processor from how much it is a "spatial" vs. "temporal" PE (in fact, those lines are blurred here).
* The language should still allow the meta-proramming techniques already used in hardware design. As a specific example, things like bit-width of wires and registers should be template-able.
* Distinction between arch and impl.
* Interconnect implicitly specifies constraints which provide a contract for memories and pe's.
* Halide like system: similar to decoupling "algorithm" and "schedule", we want to decouple "architecture" and "implementation" (or "functional spec" and "implementation"). In this way we can enable good RTL generation by providing programmer with abstractios which guide the "implementation", but there exists some notion of a naive or default implementation (similar to Halide, wherein you can provide a custom schedule or simply perform a naive/default schedule). Furthering this analogy, a useful tool would be an automatic method to produce optimized RTL, similar to efforts to design a Halide "auto-scheduler".
* Much of the need to maintain hard architectural boundaries over time (i.e. fully backwards compatible ISA's) is due to the huge overhead of rewriting the software tools for each new architecture (e.g. compiler, assembler, disassembler). The need to maintain this hard boundary is not so important if we automatically generate some of these software tools.
* How to define state?
