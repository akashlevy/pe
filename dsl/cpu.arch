import math

# Config state. This is included here for completeness but is not actually
# used. Even in a CPU we may have some important configuration state.
var quantitative config perf_counter(16);

# The special variable "instruction" does not require a bit length argument, nor
# does it accept the "quantitative" or "nominal" qualifier (since it is always
# assumed to be nominal).
var dynamic instruction;

# We can metaprogram by using arbitrary python code.
NUM_REGISTERS = 32
REG_WIDTH = 16
regfile R(NUM_REGISTSERS, REG_WIDTH)
reg_bits = r.address_size()

# We can also declare a memory the same way we do a regfile.
MEMORY_SIZE = 1 << REG_WIDTH
MEMORY_WORD = 16
memory M(MEMORY_SIZE, MEMORY_WORD)

# Here we declare all inputs used by all instructions. Note that not all
# operations will use all of these. For example, binary arithmetic ops will use
# src0, src1, and dst0, whereas memory references may use src0, imm, and dst. In
# any case, we must specify all inputs upfront and we can use them in anyway we
# want downstream.
var quantitative dynamic src0(reg_bits);
var quantitative dynamic src1(reg_bits);
var quantitative dynamic dst(reg_bits);
var quantitative dynamic imm(10);

# We create intermediate values for the actual values coming from the reg files
# (src0, src1, dst are just reg file indices). Note that the syntax for
# registers has not been worked out - this is just a proxy.
r_a = R[src0]
r_b = R[src1]
reg_wb = 0
op add : reg_wb <= r_a + r_b
op sub : reg_wb <= r_a + ~r_b + 1
op abs : reg_wb <= (0 - r_a) if r_a[15] else r_a
op ld  : reg_wb <= M[r_a]  # simple load instruction

R[dst] <= reg_wb
# Note: This is an example of an invalid instruction due to restrictions on how
# memory can be read and written. Nested memory references should not be
# allowed, because memory can be read from once per instruction.
#op foo : r_dst <= M[M[r_a]]
# TODO(raj): Add remaining ops.

# NOTES:
# -- Providing switch case-like primitive?
# -- Quant/Nominal for 1-bit inputs? Special syntax for 1-bit inputs?
# -- How to capture state?
